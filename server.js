import express from 'express';\nimport { createServer } from 'http';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport sockjs from 'sockjs';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst app = express();\nconst server = createServer(app);\nconst PORT = process.env.PORT || 3000;\n\n// Serve static files\napp.use(express.static(path.join(__dirname, 'public')));\n\n// Epic Card Battle Game State\nconst gameState = {\n  players: new Map(),\n  games: new Map(),\n  lobbies: new Map(),\n  quickMatchQueue: new Set()\n};\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'OK',\n    service: 'Epic Card Battle with SockJS',\n    timestamp: new Date().toISOString(),\n    players: gameState.players.size,\n    games: gameState.games.size,\n    lobbies: gameState.lobbies.size,\n    technology: 'SockJS'\n  });\n});\n\n// Serve main game page\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\n// SockJS server setup\nconst sockjsServer = sockjs.createServer({\n  sockjs_url: 'https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js',\n  log: (severity, message) => {\n    console.log(`[SockJS ${severity}] ${message}`);\n  }\n});\n\n// SockJS connection handling\nsockjsServer.on('connection', (conn) => {\n  console.log(`ğŸ® Player connected: ${conn.id}`);\n\n  // Register player when they send their info\n  conn.on('data', (message) => {\n    try {\n      const data = JSON.parse(message);\n      handleMessage(conn, data);\n    } catch (error) {\n      console.error('Message parse error:', error);\n      sendError(conn, 'Invalid message format');\n    }\n  });\n\n  conn.on('close', () => {\n    handleDisconnect(conn);\n  });\n});\n\n// Message handler\nfunction handleMessage(conn, data) {\n  console.log(`ğŸ“¨ Message from ${conn.id}:`, data.type);\n\n  switch (data.type) {\n    case 'register':\n      handleRegister(conn, data);\n      break;\n    case 'find-quick-match':\n      handleQuickMatch(conn);\n      break;\n    case 'create-game':\n      handleCreateGame(conn, data);\n      break;\n    case 'join-game':\n      handleJoinGame(conn, data);\n      break;\n    case 'get-lobbies':\n      handleGetLobbies(conn);\n      break;\n    case 'card-played':\n      handleCardPlayed(conn, data);\n      break;\n    case 'end-turn':\n      handleEndTurn(conn, data);\n      break;\n    case 'ping':\n      send(conn, { type: 'pong', timestamp: Date.now() });\n      break;\n    default:\n      sendError(conn, 'Unknown message type: ' + data.type);\n  }\n}\n\n// Register player\nfunction handleRegister(conn, data) {\n  const player = {\n    id: conn.id,\n    name: data.name || `Player${Math.floor(Math.random() * 1000)}`,\n    status: 'online',\n    gameId: null,\n    conn: conn,\n    joinedAt: Date.now()\n  };\n  \n  gameState.players.set(conn.id, player);\n  \n  send(conn, {\n    type: 'registered',\n    playerId: conn.id,\n    playerName: player.name,\n    message: 'Successfully connected with SockJS!'\n  });\n  \n  broadcastPlayersList();\n  console.log(`ğŸ‘¤ Player registered: ${player.name}`);\n}\n\n// Quick Match System\nfunction handleQuickMatch(conn) {\n  const player = gameState.players.get(conn.id);\n  if (!player) return;\n\n  console.log(`âš¡ Quick match request from: ${player.name}`);\n\n  if (gameState.quickMatchQueue.size > 0) {\n    // Match with waiting player\n    const waitingPlayerId = Array.from(gameState.quickMatchQueue)[0];\n    const waitingPlayer = gameState.players.get(waitingPlayerId);\n    \n    if (waitingPlayer) {\n      gameState.quickMatchQueue.delete(waitingPlayerId);\n      \n      // Create game\n      const gameId = generateGameId();\n      const game = createGame(gameId, waitingPlayer, player);\n      \n      // Notify both players\n      send(waitingPlayer.conn, {\n        type: 'match-found',\n        gameId,\n        opponent: { id: player.id, name: player.name },\n        isHost: true\n      });\n      \n      send(conn, {\n        type: 'match-found',\n        gameId,\n        opponent: { id: waitingPlayer.id, name: waitingPlayer.name },\n        isHost: false\n      });\n      \n      // Start game after 3 seconds\n      setTimeout(() => {\n        broadcast(gameId, {\n          type: 'game-start',\n          gameId,\n          firstPlayer: waitingPlayer.id,\n          message: 'Quick match game starting!'\n        });\n      }, 3000);\n      \n      console.log(`âš¡ Quick match created: ${waitingPlayer.name} vs ${player.name}`);\n    }\n  } else {\n    // Add to queue\n    gameState.quickMatchQueue.add(conn.id);\n    \n    send(conn, {\n      type: 'searching-match',\n      message: 'Searching for opponent...',\n      queuePosition: gameState.quickMatchQueue.size\n    });\n    \n    console.log(`âš¡ Player added to queue: ${player.name}`);\n  }\n}\n\n// Create Game\nfunction handleCreateGame(conn, data) {\n  const player = gameState.players.get(conn.id);\n  if (!player) return;\n\n  const gameId = data.gameId || generateGameId();\n  const game = {\n    id: gameId,\n    host: player.id,\n    hostName: player.name,\n    players: [player],\n    status: 'waiting',\n    maxPlayers: 2,\n    gameMode: data.gameMode || 'Standard',\n    createdAt: Date.now(),\n    isPrivate: data.isPrivate || false\n  };\n\n  gameState.games.set(gameId, game);\n  if (!game.isPrivate) {\n    gameState.lobbies.set(gameId, game);\n  }\n  \n  player.gameId = gameId;\n\n  send(conn, {\n    type: 'game-created',\n    gameId,\n    hostId: player.id,\n    message: 'Game room created successfully!'\n  });\n\n  broadcastLobbyList();\n  console.log(`ğŸ  Game created: ${gameId} by ${player.name}`);\n}\n\n// Join Game\nfunction handleJoinGame(conn, data) {\n  const player = gameState.players.get(conn.id);\n  const game = gameState.games.get(data.gameId);\n  \n  if (!player || !game) {\n    sendError(conn, 'Game not found');\n    return;\n  }\n\n  if (game.players.length >= game.maxPlayers) {\n    sendError(conn, 'Game is full');\n    return;\n  }\n\n  if (game.status !== 'waiting') {\n    sendError(conn, 'Game already started');\n    return;\n  }\n\n  // Add player to game\n  game.players.push(player);\n  player.gameId = data.gameId;\n\n  // Notify all players in the game\n  game.players.forEach(p => {\n    send(p.conn, {\n      type: 'player-joined',\n      gameId: data.gameId,\n      player: { id: player.id, name: player.name },\n      players: game.players.map(p => ({ id: p.id, name: p.name })),\n      message: `${player.name} joined the game!`\n    });\n  });\n\n  // Auto-start when full\n  if (game.players.length >= game.maxPlayers) {\n    gameState.lobbies.delete(data.gameId);\n    broadcastLobbyList();\n    \n    game.status = 'playing';\n    setTimeout(() => {\n      broadcast(data.gameId, {\n        type: 'game-start',\n        gameId: data.gameId,\n        firstPlayer: game.host,\n        players: game.players.map(p => p.id),\n        message: 'Game starting!'\n      });\n    }, 2000);\n  }\n\n  console.log(`ğŸšª Player joined: ${player.name} -> ${data.gameId}`);\n}\n\n// Get Lobbies\nfunction handleGetLobbies(conn) {\n  const lobbies = Array.from(gameState.lobbies.values())\n    .filter(lobby => lobby.status === 'waiting')\n    .map(lobby => ({\n      gameId: lobby.id,\n      hostName: lobby.hostName,\n      players: lobby.players.length,\n      maxPlayers: lobby.maxPlayers,\n      gameMode: lobby.gameMode,\n      waitTime: Math.floor((Date.now() - lobby.createdAt) / 60000) + 'm'\n    }));\n\n  send(conn, { type: 'lobby-list', lobbies });\n}\n\n// Handle game actions\nfunction handleCardPlayed(conn, data) {\n  const player = gameState.players.get(conn.id);\n  if (!player || !player.gameId) return;\n\n  const game = gameState.games.get(player.gameId);\n  if (!game) return;\n\n  // Broadcast to other players\n  game.players.forEach(p => {\n    if (p.id !== conn.id) {\n      send(p.conn, {\n        type: 'opponent-card-played',\n        playerId: conn.id,\n        playerName: player.name,\n        ...data\n      });\n    }\n  });\n}\n\nfunction handleEndTurn(conn, data) {\n  const player = gameState.players.get(conn.id);\n  if (!player || !player.gameId) return;\n\n  const game = gameState.games.get(player.gameId);\n  if (!game) return;\n\n  const currentIndex = game.players.findIndex(p => p.id === conn.id);\n  const nextIndex = (currentIndex + 1) % game.players.length;\n  const nextPlayer = game.players[nextIndex];\n  \n  if (nextPlayer) {\n    broadcast(player.gameId, {\n      type: 'turn-changed',\n      gameId: player.gameId,\n      currentPlayer: nextPlayer.id,\n      playerName: nextPlayer.name\n    });\n  }\n}\n\n// Disconnect handling\nfunction handleDisconnect(conn) {\n  const player = gameState.players.get(conn.id);\n  \n  if (player) {\n    console.log(`ğŸ‘‹ Player disconnected: ${player.name}`);\n    \n    // Remove from quick match queue\n    gameState.quickMatchQueue.delete(conn.id);\n    \n    // Handle game cleanup\n    if (player.gameId) {\n      const game = gameState.games.get(player.gameId);\n      if (game) {\n        // Notify other players\n        game.players.forEach(p => {\n          if (p.id !== conn.id) {\n            send(p.conn, {\n              type: 'player-disconnected',\n              playerId: conn.id,\n              playerName: player.name,\n              message: `${player.name} disconnected`\n            });\n          }\n        });\n        \n        // Remove game if empty or host left\n        game.players = game.players.filter(p => p.id !== conn.id);\n        if (game.players.length === 0 || game.host === conn.id) {\n          gameState.games.delete(player.gameId);\n          gameState.lobbies.delete(player.gameId);\n          broadcastLobbyList();\n        }\n      }\n    }\n    \n    // Remove player\n    gameState.players.delete(conn.id);\n    broadcastPlayersList();\n  }\n}\n\n// Helper Functions\nfunction generateGameId() {\n  return Math.random().toString(36).substring(2, 8).toUpperCase();\n}\n\nfunction createGame(gameId, player1, player2) {\n  const game = {\n    id: gameId,\n    host: player1.id,\n    hostName: player1.name,\n    players: [player1, player2],\n    status: 'playing',\n    maxPlayers: 2,\n    gameMode: 'Standard',\n    createdAt: Date.now()\n  };\n  \n  gameState.games.set(gameId, game);\n  player1.gameId = gameId;\n  player2.gameId = gameId;\n  \n  return game;\n}\n\nfunction send(conn, message) {\n  try {\n    conn.write(JSON.stringify(message));\n  } catch (error) {\n    console.error('Send error:', error);\n  }\n}\n\nfunction sendError(conn, message) {\n  send(conn, {\n    type: 'error',\n    message: message\n  });\n}\n\nfunction broadcast(gameId, message) {\n  const game = gameState.games.get(gameId);\n  if (game) {\n    game.players.forEach(player => {\n      send(player.conn, message);\n    });\n  }\n}\n\nfunction broadcastPlayersList() {\n  const players = Array.from(gameState.players.values())\n    .map(player => ({\n      id: player.id,\n      name: player.name,\n      status: player.gameId ? 'In Game' : 'Online'\n    }));\n  \n  const message = { type: 'players-list', players, count: players.length };\n  \n  gameState.players.forEach(player => {\n    send(player.conn, message);\n  });\n}\n\nfunction broadcastLobbyList() {\n  const lobbies = Array.from(gameState.lobbies.values())\n    .filter(lobby => lobby.status === 'waiting')\n    .map(lobby => ({\n      gameId: lobby.id,\n      hostName: lobby.hostName,\n      players: lobby.players.length,\n      maxPlayers: lobby.maxPlayers,\n      gameMode: lobby.gameMode,\n      waitTime: Math.floor((Date.now() - lobby.createdAt) / 60000) + 'm'\n    }));\n  \n  const message = { type: 'lobby-list', lobbies, total: lobbies.length };\n  \n  gameState.players.forEach(player => {\n    send(player.conn, message);\n  });\n}\n\n// Install SockJS server\nsockjsServer.installHandlers(server, { prefix: '/sockjs' });\n\n// Start server\nserver.listen(PORT, () => {\n  console.log('ğŸš€ Epic Card Battle Server with SockJS');\n  console.log(`ğŸ“¡ Server running on port ${PORT}`);\n  console.log(`ğŸŒ Visit: http://localhost:${PORT}`);\n  console.log(`ğŸ”— Health: http://localhost:${PORT}/health`);\n  console.log(`ğŸ“Š SockJS endpoint: /sockjs`);\n  console.log('ğŸ® Ready for multiplayer battles!');\n});\n\nexport default server;