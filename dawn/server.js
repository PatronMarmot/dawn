import express from 'express';\nimport { createServer } from 'http';\nimport { Server } from 'socket.io';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst app = express();\nconst server = createServer(app);\nconst io = new Server(server, {\n  cors: {\n    origin: \"*\",\n    methods: [\"GET\", \"POST\"]\n  }\n});\n\nconst PORT = process.env.PORT || 3000;\n\n// Serve static files\napp.use(express.static(path.join(__dirname, 'public')));\n\n// Epic Card Battle Game State\nconst gameState = {\n  players: new Map(),\n  games: new Map(),\n  lobbies: new Map(),\n  quickMatchQueue: new Set()\n};\n\n// Serve main game page\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'OK',\n    service: 'Epic Card Battle',\n    timestamp: new Date().toISOString(),\n    players: gameState.players.size,\n    games: gameState.games.size,\n    lobbies: gameState.lobbies.size\n  });\n});\n\n// Socket.io connection handling\nio.on('connection', (socket) => {\n  console.log(`🎮 Player connected: ${socket.id}`);\n\n  // Register player\n  socket.on('register', (playerData) => {\n    const player = {\n      id: socket.id,\n      name: playerData.name || `Player${Math.floor(Math.random() * 1000)}`,\n      status: 'online',\n      gameId: null,\n      joinedAt: Date.now()\n    };\n    \n    gameState.players.set(socket.id, player);\n    \n    socket.emit('registered', {\n      playerId: socket.id,\n      playerName: player.name,\n      message: 'Successfully connected to Epic Card Battle!'\n    });\n    \n    // Broadcast updated player list\n    broadcastPlayersList();\n    \n    console.log(`👤 Player registered: ${player.name}`);\n  });\n\n  // Quick Match System\n  socket.on('find-quick-match', () => {\n    const player = gameState.players.get(socket.id);\n    if (!player) return;\n\n    console.log(`⚡ Quick match request from: ${player.name}`);\n\n    if (gameState.quickMatchQueue.size > 0) {\n      // Match with waiting player\n      const waitingPlayerId = Array.from(gameState.quickMatchQueue)[0];\n      const waitingPlayer = gameState.players.get(waitingPlayerId);\n      \n      if (waitingPlayer) {\n        gameState.quickMatchQueue.delete(waitingPlayerId);\n        \n        // Create game\n        const gameId = generateGameId();\n        const game = createGame(gameId, waitingPlayer, player);\n        \n        // Notify both players\n        io.to(waitingPlayerId).emit('match-found', {\n          gameId,\n          opponent: { id: player.id, name: player.name },\n          isHost: true\n        });\n        \n        socket.emit('match-found', {\n          gameId,\n          opponent: { id: waitingPlayer.id, name: waitingPlayer.name },\n          isHost: false\n        });\n        \n        // Start game after 3 seconds\n        setTimeout(() => {\n          io.to(gameId).emit('game-start', {\n            gameId,\n            firstPlayer: waitingPlayer.id,\n            message: 'Quick match game starting!'\n          });\n        }, 3000);\n        \n        console.log(`⚡ Quick match created: ${waitingPlayer.name} vs ${player.name}`);\n      }\n    } else {\n      // Add to queue\n      gameState.quickMatchQueue.add(socket.id);\n      \n      socket.emit('searching-match', {\n        message: 'Searching for opponent...',\n        queuePosition: gameState.quickMatchQueue.size\n      });\n      \n      console.log(`⚡ Player added to queue: ${player.name}`);\n    }\n  });\n\n  // Create Custom Game\n  socket.on('create-game', (gameData) => {\n    const player = gameState.players.get(socket.id);\n    if (!player) return;\n\n    const gameId = gameData.gameId || generateGameId();\n    const game = {\n      id: gameId,\n      host: player.id,\n      hostName: player.name,\n      players: [player],\n      status: 'waiting',\n      maxPlayers: 2,\n      gameMode: gameData.gameMode || 'Standard',\n      createdAt: Date.now(),\n      isPrivate: gameData.isPrivate || false\n    };\n\n    gameState.games.set(gameId, game);\n    if (!game.isPrivate) {\n      gameState.lobbies.set(gameId, game);\n    }\n    \n    player.gameId = gameId;\n    socket.join(gameId);\n\n    socket.emit('game-created', {\n      gameId,\n      hostId: player.id,\n      message: 'Game room created successfully!'\n    });\n\n    // Broadcast updated lobby list\n    broadcastLobbyList();\n    \n    console.log(`🏠 Game created: ${gameId} by ${player.name}`);\n  });\n\n  // Join Game\n  socket.on('join-game', (data) => {\n    const player = gameState.players.get(socket.id);\n    const game = gameState.games.get(data.gameId);\n    \n    if (!player || !game) {\n      socket.emit('join-error', { message: 'Game not found' });\n      return;\n    }\n\n    if (game.players.length >= game.maxPlayers) {\n      socket.emit('join-error', { message: 'Game is full' });\n      return;\n    }\n\n    if (game.status !== 'waiting') {\n      socket.emit('join-error', { message: 'Game already started' });\n      return;\n    }\n\n    // Add player to game\n    game.players.push(player);\n    player.gameId = data.gameId;\n    socket.join(data.gameId);\n\n    // Notify all players in the game\n    io.to(data.gameId).emit('player-joined', {\n      gameId: data.gameId,\n      player: { id: player.id, name: player.name },\n      players: game.players.map(p => ({ id: p.id, name: p.name })),\n      message: `${player.name} joined the game!`\n    });\n\n    // Remove from lobby list if full\n    if (game.players.length >= game.maxPlayers) {\n      gameState.lobbies.delete(data.gameId);\n      broadcastLobbyList();\n      \n      // Auto-start game\n      game.status = 'playing';\n      setTimeout(() => {\n        io.to(data.gameId).emit('game-start', {\n          gameId: data.gameId,\n          firstPlayer: game.host,\n          players: game.players.map(p => p.id),\n          message: 'Game starting!'\n        });\n      }, 2000);\n    }\n\n    console.log(`🚪 Player joined: ${player.name} -> ${data.gameId}`);\n  });\n\n  // Get Lobby List\n  socket.on('get-lobbies', () => {\n    const lobbies = Array.from(gameState.lobbies.values())\n      .filter(lobby => lobby.status === 'waiting')\n      .map(lobby => ({\n        gameId: lobby.id,\n        hostName: lobby.hostName,\n        players: lobby.players.length,\n        maxPlayers: lobby.maxPlayers,\n        gameMode: lobby.gameMode,\n        waitTime: Math.floor((Date.now() - lobby.createdAt) / 60000) + 'm'\n      }));\n\n    socket.emit('lobby-list', { lobbies });\n  });\n\n  // Game Actions\n  socket.on('card-played', (data) => {\n    socket.to(data.gameId).emit('opponent-card-played', {\n      playerId: socket.id,\n      ...data\n    });\n  });\n\n  socket.on('spell-cast', (data) => {\n    socket.to(data.gameId).emit('opponent-spell-cast', {\n      playerId: socket.id,\n      ...data\n    });\n  });\n\n  socket.on('end-turn', (data) => {\n    const game = gameState.games.get(data.gameId);\n    if (game) {\n      const currentIndex = game.players.findIndex(p => p.id === socket.id);\n      const nextIndex = (currentIndex + 1) % game.players.length;\n      const nextPlayer = game.players[nextIndex];\n      \n      io.to(data.gameId).emit('turn-changed', {\n        gameId: data.gameId,\n        currentPlayer: nextPlayer.id,\n        playerName: nextPlayer.name\n      });\n    }\n  });\n\n  // Player Challenge System\n  socket.on('challenge-player', (data) => {\n    const challenger = gameState.players.get(socket.id);\n    const target = gameState.players.get(data.targetId);\n    \n    if (challenger && target) {\n      io.to(data.targetId).emit('player-challenge', {\n        challengerId: challenger.id,\n        challengerName: challenger.name,\n        message: `${challenger.name} challenges you to a duel!`\n      });\n      \n      socket.emit('challenge-sent', {\n        targetName: target.name\n      });\n    }\n  });\n\n  socket.on('accept-challenge', (data) => {\n    const accepter = gameState.players.get(socket.id);\n    const challenger = gameState.players.get(data.challengerId);\n    \n    if (accepter && challenger) {\n      // Create private game\n      const gameId = generateGameId();\n      const game = createGame(gameId, challenger, accepter, true);\n      \n      io.to(data.challengerId).emit('challenge-accepted', {\n        gameId,\n        opponent: { id: accepter.id, name: accepter.name }\n      });\n      \n      socket.emit('challenge-accepted', {\n        gameId,\n        opponent: { id: challenger.id, name: challenger.name }\n      });\n    }\n  });\n\n  // Disconnect handling\n  socket.on('disconnect', (reason) => {\n    const player = gameState.players.get(socket.id);\n    \n    if (player) {\n      console.log(`👋 Player disconnected: ${player.name} (${reason})`);\n      \n      // Remove from quick match queue\n      gameState.quickMatchQueue.delete(socket.id);\n      \n      // Handle game cleanup\n      if (player.gameId) {\n        const game = gameState.games.get(player.gameId);\n        if (game) {\n          // Notify other players\n          socket.to(player.gameId).emit('player-disconnected', {\n            playerId: socket.id,\n            playerName: player.name,\n            message: `${player.name} disconnected`\n          });\n          \n          // Remove game if empty or host left\n          game.players = game.players.filter(p => p.id !== socket.id);\n          if (game.players.length === 0 || game.host === socket.id) {\n            gameState.games.delete(player.gameId);\n            gameState.lobbies.delete(player.gameId);\n            broadcastLobbyList();\n          }\n        }\n      }\n      \n      // Remove player\n      gameState.players.delete(socket.id);\n      broadcastPlayersList();\n    }\n  });\n});\n\n// Helper Functions\nfunction generateGameId() {\n  return Math.random().toString(36).substring(2, 8).toUpperCase();\n}\n\nfunction createGame(gameId, player1, player2, isPrivate = false) {\n  const game = {\n    id: gameId,\n    host: player1.id,\n    hostName: player1.name,\n    players: [player1, player2],\n    status: 'playing',\n    maxPlayers: 2,\n    gameMode: 'Standard',\n    createdAt: Date.now(),\n    isPrivate\n  };\n  \n  gameState.games.set(gameId, game);\n  player1.gameId = gameId;\n  player2.gameId = gameId;\n  \n  // Join socket rooms\n  io.sockets.sockets.get(player1.id)?.join(gameId);\n  io.sockets.sockets.get(player2.id)?.join(gameId);\n  \n  return game;\n}\n\nfunction broadcastPlayersList() {\n  const players = Array.from(gameState.players.values())\n    .map(player => ({\n      id: player.id,\n      name: player.name,\n      status: player.gameId ? 'In Game' : 'Online'\n    }));\n  \n  io.emit('players-list', { players, count: players.length });\n}\n\nfunction broadcastLobbyList() {\n  const lobbies = Array.from(gameState.lobbies.values())\n    .filter(lobby => lobby.status === 'waiting')\n    .map(lobby => ({\n      gameId: lobby.id,\n      hostName: lobby.hostName,\n      players: lobby.players.length,\n      maxPlayers: lobby.maxPlayers,\n      gameMode: lobby.gameMode,\n      waitTime: Math.floor((Date.now() - lobby.createdAt) / 60000) + 'm'\n    }));\n  \n  io.emit('lobby-list', { lobbies, total: lobbies.length });\n}\n\n// Start server\nserver.listen(PORT, () => {\n  console.log(`🚀 Epic Card Battle Server running on port ${PORT}`);\n  console.log(`🌐 Visit: http://localhost:${PORT}`);\n  console.log(`🔗 Health: http://localhost:${PORT}/health`);\n  console.log(`📊 Socket.io ready for connections`);\n});\n\nexport default server;